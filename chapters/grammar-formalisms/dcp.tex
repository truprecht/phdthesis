\documentclass[../../document.tex]{subfiles}

\begin{document}
    \section{Definite Clause Programs (\abrv{dcp})}
    \abrv{Dcp} are, in contrast to \abrv{lcfrs}, a formalism where each rule produces trees instead of plain strings.
    The most striking difference to the previous formalism, however, lies in the composition expressions contained in each rule:
    They do not only allow substitution with parameters produced by successors in a derivation (first order substitution), but each single parameter may also contain variables that are substituted in the same step (second order substitution).
    This corresponds to the information flow from bottom to the top in a derivation as expressed by synthetic attributes (first order substitution), as well as the information flow from top to the bottom in a derivation by inherent attributes (second order substitution) in attribute grammars.
    The implementation of these two systems of substitution, two pairwise distinct sets of variables are used: \(\X\) for the first (as in \abrv{lcfrs}), and \(\Y\) for the second order substitution.

    In their most general form, the object produced by a derivation in such a \abrv{dcp} is not necessarily computable, as the two types of substitution may mutually recur.
    To solve this issue, there were some restrictive forms introduced which exclude circular dependencies in the expressed productions. \citep[Sec.~3.4 about non-circular attribute grammars]{Cou82}
    It is easy to see that the definition shown in this section supersedes each of these restricted forms, as it exclusively allows fixed terminal objects or a single second order variable as parameter for second order substitution.
    To avoid unnecessarily complicated definitions, the subset of \abrv{dcp} shown in this section is even further restricted such that
    \begin{inparaenum}
        \item each composition yields one sequence of consecutive trees (and not sequences of ranges) that is a subforest in the parse, and
        \item each rule's composition expression allows exactly one second-order substitution (which may be the empty sequence).
    \end{inparaenum}

    \begin{definition}[Composition]
        We fix the \(\DN\)-family of finite sets of variables \((\X_k = \{\x_i \mid i \in [k]\} \mid k \in \DN)\), and the singleton set \(\Y = \{\y\}\).
        The identifier \(\X\) denotes the union \(\bigcup_{k \in \DN} \X_k = \{\x_i \mid i \in \DN\}\).
        Let \(\varSigma\) and \(\varGamma\) be alphabets disjoint from \(\X \cup \Y\).
        The \(\DN\)-family \((S_k = \{x(y) \mid x \in \X_k, y \in \T_\varGamma(\varSigma \cup Y)^*\} \mid k \in \DN)\) denotes expressions for occurrences of first-order substitutions using \(k\) variables.
        The \(\DN\)-family of \abrv{dcp} \deflab<\dcp>[dcp:comp]{composition}[compositions] over \(\varSigma\) and \(\varGamma\) is \((\C^{\varGamma\varSigma}_k \mid k \in \DN)\) such that \(\C^{\varGamma\varSigma}_k\) contains each nonempty sequence \(c\) in \((\T_\varGamma(\varSigma \cup \Y \cup S_k))^+\) such that each variable in \(\X_k \cup \Y\) occurs exactly once in \(c\).
        We associate the identifier \(\C^{\varGamma\varSigma}\) with the set of all such \abrv{dcp} compositions \(\bigcup_{k \in \DN} \C^{\varGamma\varSigma}_{k}\).

        Each composition \(c \in \C^{\varGamma\varSigma}_k\) is associated with a function \[
        \sem{c}\colon \big(\T_\varGamma(\varSigma \cup Y)^*\big)^k \to \T_\varGamma(\varSigma \cup Y)^*
        \] such that \(\sem{c}(\xi_1, \ldots, \xi_k) = c[\x_1=\xi_1, \ldots, \x_k=\xi_k]\) is the second-order substitution of \(\X_k\) in \(c\).
    \end{definition}

    %    The occurrences of variables are abbreviated in the following two ways:
    %    \begin{compactenum}
        %        \item Variables in \(\X\) with successor \(\varepsilon\) are abbreviated by omitting the parentheses and the successor as a whole; e.g.\@ instead of \(\x_1(\varepsilon)\), we just write \(\x_1\).
        %        \item We omit trailing occurrences of the variable \(\y\), if it does not occur as a successor of any node; e.g.\@ instead of \(\text{S}(\x_1)\,\y \), we just write \(\text{S}(\x_1)\).
        %    \end{compactenum}

    \begin{example}\label{ex:dcp:comp}
        Consider the following compositions over the alphabets \(\varSigma = \{ \cn{sbar}, \cn{s}, \cn{vp}, \cn{np} \}\) and \(\varGamma = \{\tn{where}, \tn{the}, \tn{survey}, \tn{was}, \tn{carried}, \tn{out}\}\):
        \begin{align*}
            c_1 &= \tn{where} \, \y,
            &c_2 &= \y \, \tn{out},
            &c_3 &= \cn{np} (\y \, \tn{survey}) && \in \C_0\\
            c_4 &= \cn{vp}(\x_1(\y) \, \tn{was}) && && && \in \C_1 \\
            c_5 &= \cn{sbar} (\cn{s} (\x_1(\y) \, \x_2(\tn{the}))),
            &c_6 &= \cn{vp}(\x_1(\y) \, \x_2(\tn{carried})) && && \in \C_2
        \end{align*}
        The subscript indexing the family of compositions \(\C\) determines the number of arguments for the functions represented by the elements in \(\C\).
        E.g.\@ \(\sem{c_1}\) takes no arguments, and \(\sem{c_6}\) takes two arguments.
        Evaluating any term of such compositions yields a sequence tree in \(\T_\varSigma(\varGamma \cup \Y)\) with exactly one occurrence of \(\y\), for example:
        \begin{align*}
            \sem{c_6} \big( \sem{c_1}(), \sem{c_2}() \big)
            &= \sem{c_6} \big( \: (\tn{where} \, \y), \: (\y \, \tn{out}) \: \big) \\
            &= \cn{vp}(\x_1(\y) \, \x_2(\tn{carried}))[\x_1=(\tn{where} \, \y), \x_2=(\y \, \tn{out})] \\
            &= \cn{vp}(\x_1 \, \x_2)[\x_1=(\tn{where} \, \y)[\y=\y], \x_2=(\y \, \tn{out})[\y=\tn{carried}]] \\
            &= \cn{vp}(\x_1 \, \x_2)[\x_1=(\tn{where} \, \y), \x_2=(\tn{carried out})] \\
            &= \cn{vp}(\tn{where} \, \y \, \tn{carried out})
        \end{align*}
    \end{example}

    Aside from the form of the compositions (and therefore also the concept of fan-out), \abrv{dcp} grammars, derivations and most of the concepts of rule and grammar forms are defined analogously to \abrv{lcfrs} grammars and we will refrain from repeating them completely but focus on the differences to \abrv{lcfrs} grammars.
    As we have seen \abrv{dcp} compositions contain elements from two alphabets, \(\varGamma\) for inner nodes (which we will assume to be constituent symbols) and  \(\varSigma\) for leaf nodes (tokens or sentence positions, respectively), only the symbols in \(\varSigma\) are considered lexical symbols.
    The tuple for a \abrv{dcp} grammar is hence extended by the additional alphabet and assumes the form \((N, \varGamma, \varSigma, S, R)\).
    There is no fanout in \abrv{dcp} grammars, because the sequences of trees produced by compositions are not meant to be separated.
    To avoid that a complete derivation produces more than one tree, we require that the composition in each non-nullary rule whose \abrv{lhs} nonterminal is the initial nonterminal \(S\) is of the form \(\gamma ( \omega )\) for some \(\gamma \in \varGamma\) and \(\omega \in \C^{\varGamma \varSigma}\), i.e.\@ there is at least one inner node that assembles the results of all successor rules.
    As in other grammar formalisms, the yield for a derivation recursively computes the composition functions.
    In contrast to string grammars, like \abrv{lcfrs}, the yield of a complete derivation is a tree in \(\T_\varGamma(\varGamma)\).

    As \abrv{lcfrs}, we deal with \abrv{dcp} grammars that are instantiated with sentence positions as lexical symbols during the rule extraction as well as parsing.
    The formalism does not restrict the composition functions with respect to the lexical symbols of assembled trees; each derivation is inherently \emph{admissible}.\footnote{
        Such ``unrestricted \abrv{dcp}'' showed to be infeasible for parsing during our experiments, so we equipped each rule with a fanout (which does not need to be consistent among all rules for a \abrv{lhs} nonterminal).
        This is discussed in more detail in \cref{sec:parsing}.
    }
    For each derivation \(d\) in a position instantiated \abrv{dcp}, the constituent structure for \(d\) is the yield of \(d\).

    \begin{example}[Continues \cref{ex:dcp:comp}]
        Consider a \abrv{dcp} \((N, \varGamma, [|w|], \nt{s}, R)\) that is a position instantiation for \(w = \text{''where the survey was carried out''}\), with the alphabets \(N = \{\nt{v}^\nt{L}, \nt{v}, \nt{n}, \nt{s} \}\) and \(\varGamma = \{\cn{vp}, \cn{sbar}, \cn{s}, \cn{np}\}\), and
        \begin{align*}
            R = \Big\{ \quad
            \nt{v}^\nt{L} &\to (\tn{1} \, \y)\:(),
            \quad \nt{v} \to (\y \, \tn{6})\:(),
            &\nt{n} &\to (\cn{np} (\y \, \tn{3}))\:(), \\
            \nt{v} &\to (\cn{vp}(\x_1(\y) \, \tn{4}))\:(\nt{v}),  \\
            \nt{s} &\to (\cn{sbar} (\cn{s} (\x_1(\y) \, \x_2(\tn{2}))))\:(\nt{v}, \nt{n}),
            &\nt{v} &\to (\cn{vp}(\x_1(\y) \, \x_2(\tn{5})))\:(\nt{v}^\nt{L}, \nt{v})
            \quad \Big\} \text{.}
        \end{align*}

        The tree \(d\) illustrated below (left) is a derivation in \(\derivs^R_\nt{s}\), its constituent structure \(\yield(d)\) is shown to the right.
        A part of the computations (for the bottom \(\cn{vp}\)-node) was already shown in the previous example in detail.

        \null\hfill
        \begin{tikzpicture}[level distance=6ex, font=\small, sibling distance=3.7cm, inner sep=2pt]
            \node {\(\nt{s} \to (\cn{sbar} (\cn{s} (\x_1(\y) \, \x_2(\tn{2}))))\:(\nt{v}, \nt{n})\)}
                child {node {\(\nt{v} \to (\cn{vp}(\x_1(\y) \, \tn{4}))\:(\nt{v})\)}
                    child {node {\(\nt{v} \to (\cn{vp}(\x_1(\y) \, \x_2(\tn{5})))\:(\nt{v}^\nt{L}, \nt{v})\)}
                        child {node {\(\nt{v}^\nt{L} \to (\tn{1} \, \y)\:()\)}}
                        child {node {\(\nt{v} \to (\y \, \tn{6})\:()\)}}}}
                child {node {\(\nt{n} \to (\cn{np} (\y \, \tn{3}))\:()\)}};
        \end{tikzpicture}
        \hfill
        \begin{tikzpicture}[level distance=4.5ex, font=\small, inner sep=2pt, sibling distance=4em]
            \node {\(\cn{sbar}\)} child {node {\(\cn{s}\)}
                child {node {\(\cn{vp}\)}
                    [sibling distance=3em]
                    child {node {\(\cn{vp}\)}
                        [sibling distance=2em]
                        child {node {\(\tn{1}\)}}
                        child {node {\(\tn{5}\)}}
                        child {node {\(\tn{6}\)}}}
                    child {node {\(\tn{4}\)}}}
                child {node {\(\cn{np}\)}
                    [sibling distance=2em]
                    child {node {\(\tn{2}\)}}
                    child {node {\(\tn{3}\)}}}};
        \end{tikzpicture}
        \hfill\null
    \end{example}
\end{document}