\documentclass[../../document.tex]{subfiles}

\begin{document}
    \section{Guided Extraction} \label{sec:extraction:guided}
    We implemented the extraction of \abrv{lcfrs} supertags as described in the previous section and published results in parsing with them \citep{RupMoe21}.
    During the evaluation, we noted that the extracted sets of supertags were rather large and their prediction less accurate than other publications involved with supertagging.
    Following up, we published a generalization of the extraction procedure with the aim of tackling these issues \citep{Rup22}.
    Specifically, the generalization deals with the following two limitations:
    \begin{compactitem}
        \item
            Constructing lexical \abrv{lcfrs} rules picked a sentence position for each inner node of the constituent structure according to a fixed strategy (cf.\@ step \ref{enum:lcfrs:step3} in \cref{sec:extraction:lcfrs}).
            Such a strategy is now formalized by a \emph{guide} that maps each inner node position of a constituent structure to sentence position in its yield.
            The concept is generalized by introducing multiple strategies to define guides for a given constituent structure called \emph{guide constructors}.
        \item
            LCFRS rules were constructed with constituent symbols as nonterminals, which were then supplemented with annotations during the lexicalization process.
            This section decouples the nonterminals from the other extraction processes and introduces multiple strategies to define them, called \emph{nonterminal constructors}.
    \end{compactitem}
    This section picks up on the published generalizations and describes the extraction procedure in a more formal setting with \abrv{lcfrs}/\abrv{dcp} hybrid grammar rules.
    Similar to the previous section, this extraction process is characterized by four consecutive steps:
    \begin{enumerate}
        \item\label{extraction:hg:ranktrans}
            The tree is processed by a rank transformation that is compatible with the chosen guide constructor.
            In some cases, applying no rank transformation at all may be a viable choice.
        \item\label{extraction:hg:guide}
            A guide constructor selects a sentence position for each constituent node.
        \item\label{extraction:hg:alg}
            A derivation of lexical \abrv{hg} rules for the constituent tree is constructed using the constituent tree, the guide from the previous step, and a nonterminal constructor.
        \item
            In the final step, the rules are collected as a sequence in order of the positions according to the instantiation.
            All occurring terminal symbols are replaced by a wildcard symbol \tn{*}.
            In case that we aim to extract \abrv{dcp} supertag blueprints, we replace each \abrv{hg} rule \(A \to c_1\,c_2\,(\vec{B}))\) by the tuple \((A \to c_2 (\vec{B}), |c_1|))\) that does only contain the \abrv{dcp} composition but keeps the length of the \abrv{lcfrs} composition as fanout restriction for parsing.
    \end{enumerate}
    The first two steps are explained in the following \cref{sec:guides}, which defines the concept of guide constructors, gives examples, and explains which rank transformations are sensible options.
    The concept of nonterminal constructors and some examples are discussed in \cref{sec:ntconstructors}; the remainder of \cref{extraction:hg:alg} is explained in \cref{sec:extractionalg}.

    \subsection{Guides and Guide Constructors}\label{sec:guides}
    We introduced the concept of guides for the extraction in our latest publication \citep{Rup22}.
    A guide is a function \(\varphi\) that assigns a sentence position to each inner node position \(\rho\) of a binary constituent structure \(\xi\) such that
    \begin{inparaenum}
        \item \(\varphi(\rho)\) is a leaf below the position \(\rho\), and
        \item \(\varphi\) is an injective function; that is, each sentence position is assigned to at most one inner node position.
    \end{inparaenum}
    As \(\xi\) is binary, there is exactly one sentence position that is not assigned to any inner node.
    During the grammar extraction process, which constructs a rule for each inner node position in the constituent structure, the guide is used to determine the lexical symbol in the rule.
    Intuitively, it can be seen to assign a ``responsibility'' for each inner node by a sentence position.
    The remaining sentence position is handled by a special rule that produces no constituent node.

    In this thesis, we will generalize the concept of guides by relaxing the second condition: each sentence position may be mapped to multiple inner node positions in the constituent structure.
    This allows us to define rules that produce multiple constituent nodes.
    We will use this at the end of this section to derive lexical grammars for constituent structures that are inspired by those extracted for dependency parsing.
    They are extracted such that each rule contains a lexical symbol in tandem with each inner node of the constituent structure that the lexical symbol is the lexical head of.

    \begin{definition}[Guide]\label{def:guide}
        Let \(\xi\) be an indexed tree.
        A \deflab{guide}[guide for \(\xi\)] is a function \(\varphi\colon \pos(\xi) \to \yield(\xi)\) such that for each position \(\rho \in \pos(\xi)\), the assigned leaf is in the yield at or below the position \(\varphi(\rho) \in \yield(\xi|_\rho)\).
        \begin{itemize}
            \item \(\varphi\) is called \deflab<admissible>{admissible guide}[admissible] if for each position \(\rho \in \pos(\xi)\)
            \begin{compactenum}
                \item there is at most one other leaf \(i\) below \(\rho\) besides \(\varphi(\rho)\) such that an ancestor of \(\rho\) is assigned to \(i\), i.e. \(|\{ i \in \yield(\xi|_\rho) \setminus \{\varphi(\rho)\} \mid \varphi^{-1}(i) \cap \ancestors(\rho) \neq \emptyset\}| \leq 1\), and
                \item if there is any inner descendant position \(\rho'\) of \(\rho\) with \(\varphi(\rho) = \varphi(\rho')\), then each position \(\omega \in \descendants_\xi(\rho) \cap \ancestors(\rho')\) between \(\rho\) and \(\rho'\) has the same value \(\varphi(\rho) = \varphi(\omega) = \varphi(\rho')\).
            \end{compactenum}%
            \item \(\varphi\) is called \deflab{unitary guide}[unitary] if, for each leaf \(i\), there is at most one inner node position that is assigned to \(i\), i.e., \(|\varphi^{-1}(i) \cap \npos(\xi)| \leq 1\).
        \end{itemize}
%        \(\guide(\xi)\) denotes the set of all guides for the indexed tree \(\xi\).
    \end{definition}

    The admissible property ensures that the guide may only assign the same leaf to contiguous regions of inner node positions (plus the leaf position itself).
    Each unitary guide for a binary tree is also admissible because
    \begin{inparaenum}
        \item for each subtree with \(n\) leaves, there are \(n-1\) inner nodes; if each inner node is mapped to a different leaf, there is exactly one that is not assigned to one of those inner nodes and may be assigned to an ancestor position; and
        \item there are no two different positions mapped to the same leaf.
    \end{inparaenum}

    \bigskip

    \begin{wrapfigure}[6]{r}{.3\linewidth}
        \subfile{figures/guides/example-constituents.tex}
    \end{wrapfigure}
    \parexample*
    Consider the constituent structure \(\xi\) illustrated in the right figure.
    The gray encircled integers shown next to each inner node give the value of a guide \(\varphi\) for the position.
    For example \(\varphi(\varepsilon) = \varphi(1) = \varphi(1\,1) = 4\).
    Each leaf position is assigned to its symbol.
    The guide is not unitary because three positions are mapped to the leaf $4$.
    But it is admissible; the three positions that are mapped to 4 form a chain of direct descendants.
    \\\null\exampleqed

    \begin{definition}[Guide Constructor]
        Let \(\varSigma\) be an alphabet of constituent symbols.
        A \deflab{guide constructor} is a function \(\varPhi\colon \itrees^\varSigma \parto (\DN^* \parto \DN)\) such that for each indexed tree \(\xi\) in the domain \(\dom(\varPhi)\), the partial function \(\varPhi(\xi)\) is a guide for \(\xi\).
    \end{definition}

    Guide constructors are defined as partial functions because some of our examples can only be reasonably defined for binary constituent structures.
    In the following, we will give the instances for guide constructors that were investigated by \citet{Rup22} plus one additional instance (\emph{head guide constructor}).
    Each instance \(\varPhi\) will carry a name of the form \emph{\(x\) guide constructor}.
    For each \(\xi \in \dom(\varPhi)\), the guide \(\varPhi(\xi)\) will analogously be called \emph{\(x\) guide for \(\xi\)}.

    \paragraph{Vanilla Guide Constructor.}\deflab{vanilla guide constructor}[]
    This guide constructor aims to formalize the assignment of lexical items to inner nodes achieved by the transportation in the extraction of lexical \abrv{lcfrs} rules described in the previous section.
    Similar to the prerequisites in that section, the guide is defined for binary constituent structures.
    A guide produced by this constructor maps each node position either to the rightmost\footnote{
        In the original publication \citep{Rup22}, this constructor mapped each node to its leftmost leaf that is a direct successor.
        This is a slight change in the same manner as the split of rules with two terminal symbols in step \ref{enum:lcfrs:step4} in the extraction and lexicalization of \abrv{lcfrs} (cf.\@ \cref{footnote:lcfrs:split}).
    } leaf that is a direct successor or (if not available) to the leftmost leaf in the yield of its right successor.
    It is formally defined as follows:
    \[
    \mathrm{van}(\xi)(\rho) = \begin{cases}
        \xi(\rho)   & \text{if $\rho \in \lpos(\xi)$}\\
        \max L_\rho & \text{if $L_\rho \neq \emptyset$} \\
%        \mathrm{van}(\xi)(\rho \cdot 1) & \text{if $L_\rho = \emptyset$ and $|\children(\rho) \cap \pos(\xi)| = 1$} \\
        \min\;\yield(\xi|_{\rho\cdot 2}) &\text{otherwise}
    \end{cases}
    \]
    where the set \(L_\rho\) denotes the set of leaves just below a node that was not assigned to an ancestor node:
    \begin{align*}
        L_\rho &= \big\{\xi(\rho') \in \yield(\xi) \mid \rho' \in \lpos(\xi) \cap \children(\rho) \big\} \setminus \\
        &\qquad\qquad\qquad  \big\{\mathrm{van}(\xi)(\rho') \in \yield(\xi) \mid \rho' \in \ancestors(\rho)\} \big\}
    \end{align*}
    As such, the set depends on the values of \(\mathrm{van}(\xi)\) for ancestor nodes, and the assignment must be determined for each node from top to bottom.

    \begin{theorem}
        Let \(\xi\) be some binary indexed tree.
        \begin{compactenum}
            \item \(\mathrm{van}(\xi)(\rho)\) is well defined for each \(\rho \in \pos(\xi)\).
            \item \(\mathrm{van}(\xi)\) is a guide for \(\xi\).
            \item \(\mathrm{van}(\xi)\) is unitary and therefore admissible.
        \end{compactenum}
    \end{theorem}

    \begin{proof}
        \begin{enumerate}
            \item
                The first case in the definition of \(\mathrm{van}(\xi)(\rho)\) trivially satisfies the claim for each \(\rho \in \lpos(\xi)\).
                For the remaining case \(\rho \in \npos(\xi)\), there is a connection to \cref{lem:firstviasecond} (i).
                It is important to note that for each subtree in an indexed tree, the children are ordered via the least leaf in the yield, i.e., the minimal leaf in a subtree is the leftmost leaf.
                Moreover, the set \(L_\rho\) is unambiguously determined from top to bottom for each \(\rho \in \npos(\xi)\).
                Then, either \(L_\rho \neq \emptyset\) and the value is defined, or we consider the third case in the distinction, which is well defined by \cref{lem:firstviasecond} (i).
            \item
                By definition, each assigned value is trivially an element below the argument position, and \(\mathrm{van}(\xi)\) is a guide.
            \item
                The second and third case in the definition are relevant to the unitary property.
                The second case is only effective if \(L_\rho \neq \emptyset\).
                Then, we assign a leaf not yet assigned to an ancestor; it can also not be assigned to any non-leaf descendant because it is a direct child.
                The third case must also assign uniquely determined leaves by \cref{lem:firstviasecond} (ii), and they cannot interfere with values assigned by the second case.
        \end{enumerate}
    \end{proof}

    \begin{wrapfigure}[6]{r}{.3\linewidth}
        \centering
        \subfile{figures/survey-bin.tex}
    \end{wrapfigure}
    \parexample[Vanilla Guide]
    Consider the constituent structure \(\xi\) of the running example shown to the right.
    Starting with the topmost node, the set \(L_\rho\) is empty there are no leaves among its children.
    The value \(\mathrm{van}(\xi)(\varepsilon)\) is determined by \(\min\;\yield(\xi|_{2}) = \min\;\{2,3\} = 2\).
    After that, the root's two children can be processed.
    For the node at position \(1\), the set \(L_{1}\) is \(\{4\} \setminus \{2\} = \{4\}\), therefore the value of \(\mathrm{van}(\xi)(1)\) is \(4\).
    In case of position \(2\), the set \(L_{2}\) is \(\{2,3\} \setminus \{2\} = \{3\}\) and \(\mathrm{van}(\xi)(1)=3\).
    As we continue with the nodes to the bottom, the second set in the term for \(L_\rho\) grows with the values that we assigned to the positions on the path from the root to \(\rho\) and may thus exclude considered leaves in the yield below \(\rho\).
    \exampleqed

    \paragraph{Strict Guide Constructor.}\deflab{strict guide constructor}[]
    This is a slight adjustment of the vanilla guide constructor that removes the special case where an inner node is assigned to a leaf below it.
    As mentioned previously, this constructor is defined for binary constituent structures.
    A guide constructed by it maps each inner node to the least leaf of the second successor.
    Each inner node of rank 1 assumes the assignment of its child.
    Formally, it is defined as follows:
    \[
    \mathrm{strict}(\xi)(\rho) = \begin{cases}
        \xi(\rho)   & \text{if $\rho \in \lpos(\xi)$}\\
        \min\;\yield(\xi|_{\rho\cdot 2}) &\text{otherwise}
    \end{cases}
%        \mathrm{strict}(\xi)(\rho) = \min \; \yield(\xi|_{\rho\cdot 2})
    \]

    \begin{theorem}
        Let \(\xi\) be some binary indexed tree.
        \begin{compactenum}
            \item \(\mathrm{strict}(\xi)(\rho)\) is well defined for each \(\rho \in \pos(\xi)\).
            \item \(\mathrm{strict}(\xi)\) is a guide for \(\xi\).
            \item \(\mathrm{strict}(\xi)\) is unitary and therefore admissible.
        \end{compactenum}
    \end{theorem}

    \begin{proof}
        Items (i) and (iii) easily follow from \cref{lem:firstviasecond} (i) and (ii).
        Item (ii) is (again trivially) satisfied since each assigned value is a leaf below the argument.
    \end{proof}

    \begin{example}
        The values assigned by the strict guide are independent of each other.
        E.g.\@ we may determine the values \(\mathrm{strict}(\xi)(2) = \min\;\yield(\xi|_{2\,2}) = \min\;\{3\} = 3\) or \(\mathrm{strict}(\xi)(1\,1) = \min\;\yield(\xi|_{1\,1\,2}) = \mid\;\{5,6\}\) without computing any other values beforehand.
    \end{example}

    \paragraph{Least and Near Guide Constructors.}
    These two guide constructors were developed to
    \begin{inparaenum}
        \item assign as many nodes as possible to direct children (\deflab{least guide constructor}), and
        \item assign each node to a leaf that is as close as possible (\deflab{near guide constructor}).
    \end{inparaenum}
    Both intentions are similar, but the heuristic solutions used in these constructors' definitions are sometimes different.
    \Cref{fig:guides:diff} shows an example.
    The leaf for each inner position is determined in both cases via a breadth-first search for the first leaf that was not assigned to
    \begin{inparaenum}
        \item a descendant node, or
        \item an antecedent node, respectively.
    \end{inparaenum}
    This is formalized in the equation
    \[
    g(\xi)(\rho) = \xi\big( \min^{\unlhd} \: \big\{\rho' \in \descendants(\rho) \cap \lpos(\xi) \mid \xi(\rho') \notin L^g_\rho \big\} \big)
    \]
    where \(g\) is one of \(\{\mathrm{least}, \mathrm{near}\}\), and \(\unlhd\) is the total ordering of tree positions according to breadth-first search and set \(L^g_\rho\) keeps track of the previously assigned leaves.
    The total order \(\unlhd \subseteq \DN^* \times \DN^*\) is defined such that \(\rho \unlhd \tau\) if and only if \(|\rho| < |\tau|\) or \(|\rho| = |\tau| \land \rho <^* \tau\).
    In case of
    \begin{inparaenum}
        \item \(g = \mathrm{least}\), it excludes all assigned leaves below \(\rho\) from the breadth-first search:
        \(L^{\text{least}}_\rho = \{ g(\xi)(\rho') \in \yield(\xi) \mid \rho' \in \descendants(\rho) \cap \npos(\xi) \}\); and if
        \item \(g = \mathrm{near}\), it excludes all leaves assigned to nodes above \(\rho\):
        \(L^{\text{near}}_\rho = \{ g(\xi)(\rho') \in \yield(\xi) \mid \rho' \in \ancestors(\rho) \cap \npos(\xi) \}\).
    \end{inparaenum}
    Similarly to the vanilla guide constructor, the dependencies for \(L^g_\rho\) determine the order in which the values are computed:
    \begin{inparaenum}
        \item For the least guide constructor, the values must be determined from bottom to top.
        \item For the near guide constructor, the values must be determined from top to bottom.
    \end{inparaenum}
    Since both guide constructors define surjective functions, the number of inner nodes must be less or equal to the number of leaves in each subtree of the constituent structure.
    We solve this by binarizing the constituent tree before defining the guide, but merging unary nodes (as done during the binarization) should be sufficient in general.

    \begin{figure}
        \null\hfill
        \begin{minipage}{.35\linewidth}
            \centering
            \subfile{figures/guides/different-least-guide.tex}
            \subcaption{least guide}
        \end{minipage}
        \hfill
        \begin{minipage}{.35\linewidth}
            \centering
            \subfile{figures/guides/different-near-guide.tex}
            \subcaption{near guide}
        \end{minipage}
        \hfill\null
        \caption{\label{fig:guides:diff}
            Example for different solutions for guides by the least and near guide constructors for the same tree \(\xi\).
            Whereas the least guide assigns the distant leaf 7 to the root node, the near guide assigns 4.
            The least guide assigns five of six nodes to direct children, and the near guide only three.
        }
    \end{figure}

    \begin{claim}
        Let \(\xi\) be some binary indexed tree and \(g \in \{\mathrm{least}, \mathrm{near}\}\).
        \begin{compactenum}
            \item \(g(\xi)(\rho)\) is well defined for each \(\rho \in \pos(\xi)\).
            \item \(g(\xi)\) is a guide for \(\xi\).
            \item \(g(\xi)\) is unitary and therefore admissible.
        \end{compactenum}
    \end{claim}

    \needspace{3cm}
    \begin{wrapfigure}[6]{r}{.3\linewidth}
        \centering
        \subfile{figures/survey-bin.tex}
    \end{wrapfigure}
    \parexample[Least Guide]
    The assignments for the least guide are computed from bottom to top.
    In our running example that is again illustrated to the right, we may start with the node at position \(1\,1\,2\): The set \(L_{1\,1\,2}\) is empty, as there are no inner child nodes. The assigned value \(\mathrm{least}(\xi)(1\,1\,2)\) is the leftmost leaf with the shortest distance to the node, i.e.\@ \(5\).
    Next, for the node at \(1\,1\), the set \(L_{1\,1}\) contains each leaf that was assigned to an inner child, i.e.\@ it is \(\{5\}\), and the assigned value is \(\mathrm{least}(\xi)(1\,1) = 1\).
    \exampleqed

    \begin{example}
        The construction for the near guide starts from the topmost node.
        The value \(\mathrm{near}(\xi)(\varepsilon)\) is \(2\) because it is the leftmost leaf with the shortest distance.
        For the child at position \(2\), the set \(L_{2} = \{2\}\) contains the leaves that were assigned to its ancestors.
        When \(\mathrm{near}(\xi)(2)\) is determined, the leaf \(2\) is excluded as a potential value, which leaves us the leaf \(3\).
    \end{example}

    Whereas the previous constructors were defined solely according to the constituent structure, the remaining two take some additional linguistic information into account: heads and modifiers.
    This also requires special treatment concerning binarization, which is applied to the constituent structures for the two following guide constructors.
    This is explained further in the following paragraphs.

    \paragraph{Head Guide Constructor.}
    As the name suggests, these guides assign the lexical head to each inner node of the constituent structure.
    This implements an intuitive approach to deal with the relation between the inner nodes and their assigned lexical head: For each lexical symbol, there will be a lexical rule that contains the information to produce precisely the inner nodes it is head of.
    Naturally, this requires that the constituent structure is equipped with the necessary lexical head assignment.
    Formally, consider the lexical head assignment \(\head_{(\xi,p,w)}\) for the constituent tree \((\xi, p, w)\).
    The \deflab{head guide constructor} is defined as follows: \(\mathrm{hguide}(\xi)(\rho) = \head_{(\xi,p,w)}(\rho)\).

    With this guide, our grammar extraction procedure aims to mimic the strategies established in dependency parsing \citep{kuhlmann2009treebank} as follows:
    \begin{itemize}
        \item Each constituent structure is interpreted as a dependency tree by combining the nodes that are assigned to the same lexical head. This will yield a tree consisting of sentence positions, each occurring exactly once.
        \item The \abrv{lcfrs} compositions are constructed then in the same manner as for dependency grammars: There is one for each position in the sentence; it is constructed using the ordered contiguous sequences of positions in the subtree rooted at the position such that, for each child, its sequences of positions are replaced by appropriate variable symbols.
        \item The resulting derivation has the same shape as the dependency tree. For each position in the dependency tree for the lexical head \(i\), there is a lexical rule with the terminal \(i\) in the derivation at the same position.
    \end{itemize}
    \Cref{sec:extractionalg} shows an example of the extraction of a derivation using the head guide.

    \begin{theorem}
        Let \(\xi\) be an indexed tree with a head assignment.
        \begin{compactenum}
            \item \(\mathrm{hguide}(\xi)(\rho)\) is well defined for each \(\rho \in \pos(\xi)\) and \(\mathrm{hguide}(\xi)\) is a guide for \(\xi\).
            \item \(\mathrm{hguide}(\xi)\) is admissible.
        \end{compactenum}
    \end{theorem}

    \begin{proof}
        Item (i) follows trivially from the definition of head assignments, as they map each inner node to a leaf in its yield.
        For item (ii), we consider the properties of head assignments:
        Consider a position \(\rho \in \npos(\xi)\).
        By the structure of head assignments, \(\mathrm{hguide}(\xi)(\rho) = \head(\xi|_\rho)\) is a leaf directly below \(\rho\) or the head of a child of \(\rho\).
        Therefore, any ancestor of \(\rho\) cannot be assigned to any leaf below \(\rho\) but \(\head(\xi|_\rho)\), and the function satisfies the property (i) for admissible guides.
        For the property (ii), we consider a descendant position \(\rho' \in \descendants_\xi(\rho) \setminus \{\rho\}\).
        If \(\head(\xi|_\rho) = \head(\xi|_{\rho'})\), we see again quickly the property as mentioned earlier that this leaf must also be the head at all positions between \(\rho\) and \(\rho'\).
    \end{proof}

    \paragraph{Dependent Guide Constructor.}
    Dependent guides aim to offer assignments that complement head-outward binarized constituent structures.
    They assign the head of a dependent to each inner node in the constituent structure.
    We consider these guides only for head-outward binarized constituent structures, as each inner node has precisely one dependent.
    Formally, consider the lexical head assignment \(\head_{(\xi,p,w)}\) for the constituent tree \((\xi, p, w)\).
    The \deflab{dependent guide constructor} is defined as follows:
    \[
        \mathrm{dguide}(\xi)(\rho) = \begin{cases}
            \head_{(\xi,p,w)}(\rho\cdot2) & \text{if $\rho \in \npos{\xi}$ and $\head_{(\xi,p,w)}(\rho) \in \yield(\xi|_{\rho\cdot 1})$} \\
            \head_{(\xi,p,w)}(\rho\cdot1) & \text{if $\rho \in \npos{\xi}$ and $\head_{(\xi,p,w)}(\rho) \in \yield(\xi|_{\rho\cdot 2})$} \\
            \xi(\rho) & \text{otherwise} \\
        \end{cases}
    \]

    \begin{claim}
        Let \(\xi\) be a head-outward binarized indexed tree with a head assignment.
        \begin{compactenum}
            \item \(\mathrm{dguide}(\xi)(\rho)\) is well defined for each \(\rho \in \pos(\xi)\).
            \item \(\mathrm{dguide}(\xi)\) is a guide for \(\xi\).
            \item \(\mathrm{dguide}(\xi)\) is unitary and therefore admissible.
        \end{compactenum}
    \end{claim}

    \begin{figure}
        \begin{minipage}{.27\textwidth}
            \resizebox{\textwidth}{!}{\subfile{figures/guides/example-guide-van.tex}}
            \subcaption{vanilla guide}
        \end{minipage}\hfill
        \begin{minipage}{.27\textwidth}
            \resizebox{\textwidth}{!}{\subfile{figures/guides/example-guide-strict.tex}}
            \subcaption{strict guide}
        \end{minipage}\hfill
        \begin{minipage}{.27\textwidth}
            \resizebox{\textwidth}{!}{\subfile{figures/guides/example-guide-least.tex}}
            \subcaption{least guide}
        \end{minipage}

        \vspace{.5cm}

        \begin{minipage}[b]{.27\textwidth}
            \resizebox{\textwidth}{!}{\subfile{figures/guides/example-guide-near.tex}}
            \subcaption{near guide}
        \end{minipage}\hfill
        \begin{minipage}[b]{.27\textwidth}
            \resizebox{\textwidth}{!}{\subfile{figures/guides/example-guide-head.tex}}
            \subcaption{head guide}
        \end{minipage}\hfill
        \begin{minipage}[b]{.27\textwidth}
            \resizebox{\textwidth}{!}{\subfile{figures/guides/example-guide-dep.tex}}
            \subcaption{dependent guide}
        \end{minipage}

        \caption{\label{fig:guides}
            Overview of the guide constructors in an example constituent structure.
            Gray integers show the leaf assigned to each inner node for the binary constituent structure.
            Encircled leaves are not in the image of the guide.}
    \end{figure}

    \subsection{Nonterminal Constructors}\label{sec:ntconstructors}
    A \emph{nonterminal constructor} computes \abrv{lhs} and \abrv{rhs} nonterminals for each grammar rule.
    As each grammar rule is extracted at some inner node in the constituent structure, the constructor considers the position in the inner node.
    The concept of nonterminal constructors resembles the nonterminal labeling strategies introduced by \citet[Section~6.2]{Geb20}.

    \begin{definition}[Nonterminal Constructor]
        Consider an alphabet of constituent symbols \(\varGamma\), a nonempty set of nonterminal symbols \(N\), and an \(\DN_+\)-indexed partition of \(N\) that groups the nonterminals by fanout \((\mathit{fo}_i \subseteq N \mid i \in \DN_+)\).
        A \deflab{nonterminal constructor} is a partial function \(\psi\colon \itrees_\varGamma \times \DN^* \times \power(\DN_+) \parto N\) such that \(\psi(\xi, \rho, L) \in \mathit{fo}_{\fanout(L)}\) is well-defined for each pair of an indexed tree \(\xi \in \itrees_\varGamma\), a position \(\rho \in \pos(\xi)\), and subset of leaves \(L \subseteq \yield(\xi|_\rho)\) below \(\rho\).
    \end{definition}

    %    Each of the following constructors computes a nonterminal for the position \(\rho\) in \(\xi\) from the constituent symbol \(\xi(\rho)\), the set of leaves \(\yield(\xi|_\rho)\) below \(\rho\) and the set of leaves \(L\) assigned by \(\guide\) to the ancestors of \(\rho\).
    %    We omit the fanout subscripts if they are \(1\).
    %    We give examples using the \emph{shortest guide}, as shown in \cref{fig:constituent:bin}, for the root position \(\varepsilon\) where \(\xi(\varepsilon) = \text{SBAR+S}\), \(\yield(\xi|_\varepsilon) = \{0,\ldots,5\}\) and \(L = \emptyset\) and the position \(1.1\) of the bottom VP node where \(\xi(1.1) = \text{VP}\), \(\yield(\xi|_{1.1}) = \{0,4,5\}\), \(L = \{0,3\}\) and \(\fanout(\yield(\xi|_{1.1}) \setminus L) = 1\).

    During the extraction procedure, the third argument \(L\) for a constructor assumes the set of leaves that are either
    \begin{inparaenum}
        \item assigned by the guide to nodes at or below \(\rho\), or
        \item below \(\rho\) and not in the image of the guide.
    \end{inparaenum}
    It is the set of leaves occurring in the (sub-)derivation of rules extracted at and below \(\rho\).
    The partition \(\mathit{fo}\) and its connection to the definition of each nonterminal constructor assure that the constructed nonterminals are considered with consistent fanouts.
    In the following, we will define some instances of nonterminal constructors.
    Similar to the guide constructors, each instance will carry a name of the form \emph{\(x\) nonterminal constructor}.
    The nonterminal symbols constructed by \(\psi\) are called \emph{\(x\) nonterminals}.

    \paragraph{Vanilla Nonterminal Constructor.}
    This resembles the nonterminals in the extraction in \cref{sec:extraction:lcfrs}.
    Each nonterminal is of the form \(A_{n}^{d}\) where \(A \in \varGamma\) is a constituent symbol, \(n \in \DN_+\) is a fanout of a discontinuous span in the constituent tree \(\xi\), and \(d \in \{-1,0,+1\}\) is the difference between the fanout of the extracted rule and \(f\).
    This set of \emph{vanilla nonterminals} \(N\) is partitioned such that \(\mathit{fo}_{\hat{n}} = \{ A^d_{\hat{n}-d} \in N \mid A \in \varGamma, d \in [-1,1], \hat{n}-d > 0 \}\).
    The \deflab{vanilla nonterminal constructor} is a function \(\psi\) such that \(\psi(\xi, \rho, L) = \xi(\rho)_{n}^{d}\) where \(n = \fanout(\yield(\xi|_\rho))\) and \(d = \fanout(L) - n\) for each indexed tree \(\xi \in \itrees_\varGamma\), position \(\rho \in \pos(\xi)\) and \(L \subseteq \yield(\xi|_\rho)\).
    As usual, we will abbreviate the nonterminal symbols by omitting the subscript if it is \(1\).

    \begin{wrapfigure}[6]{r}{0pt}
        \subfile{figures/guides/example-guide-dep.tex}
    \end{wrapfigure}
    \parexample[Vanilla Nonterminals]
    Let us consider the indexed tree in our running example and the constructed dependent guide illustrated to the right.
    We focus on the lower \(\cn{vp}\) node at position \(1\,1\).
    The set \(L= \{1,5\}\) is the set leaves below the node minus the leaf \(6\), which is assigned to the parent at position \(1\).
    The nonterminal is a combination of the symbol \(\xi(1\,1) = \cn{vp}\), the fanout \(\fanout(\yield(\xi|_{1\,1})) = \fanout(\{1,5,6\}) = 2\), and \(\fanout(L) - 2 = \fanout(\{1,5\})-2=0\).
    It is denoted in the form \(\cn{vp}^0_2\).
    \exampleqed

    \paragraph{Classic Nonterminal Constructor.}
    This constructor intends to produce nonterminals akin to usual strategies in LCFRS extraction \citep{MaierSogaard08}.
    It combines the superscript and subscript of the vanilla nonterminals and annotates constituent symbols with their sum.
    Moreover, each occurrence of a constituent symbol that is the product of a merge during a rank transformation (cf.\@ merging a chain of unary nodes in \cref{sec:binarization}) is replaced by the topmost constituent symbol of such chain.
    We define a modified set of constituent symbols \(\varGamma' = \{ f(\gamma) \mid \gamma \in \varGamma \}\) where \(f(\gamma)\) is the symbol obtained by replacing each occurrence of the form \(\nt{A$_1$+A$_2$+...+A$_k$}\) in \(\gamma\) by \(\nt{A$_1$}\).
    The set of \emph{classic nonterminals} is \(N = \{ A_n \mid A \in \varGamma', n \in \DN_+ \}\) and the partition \(\mathit{fo}_n = \{A_n \mid A \in \varGamma'\}\).
    The \deflab{classic nonterminal constructor} is the function \(\psi\) with \(\psi(\xi, \rho, L) = f(\xi(\rho))_{\fanout(L)}\) for each indexed tree \(\xi\), position \(\rho \in \pos(\xi)\) and set of leaves \(L \subseteq \yield(\xi|_\rho)\).

    \begin{example}
    For the classic nonterminal constructed for the root in the example indexed tree above, we determine the set \(L = \yield(\xi) = \{1,\ldots,6\}\).
    The nonterminal consists of the symbol \(\cn{sbar}\) and the fanout \(\fanout(L) = 1\) and is illustrated as \(\cn{sbar}_1\).
    \end{example}

    \paragraph{Coarse Nonterminal Constructors.}
    This constructor equals the classic nonterminal constructor for the most part, but it replaces the constituent symbol \(\xi(\rho)\) either by
    \begin{inparaenum}
        \item a symbol that subsumes multiple constituent symbols given in a separate table or
        \item its first letter.
    \end{inparaenum}
    The latter case roughly approximates the first one when such a table is unavailable.
    The \deflab{coarse nonterminal constructor} mimics the nonterminals in coarse-to-fine parsing \citep{Cha06,Tei17}.
%    For our examples, the nonterminals are \(\text{S}\) and \(\text{V}\).

    \begin{example}
        \Cref{tab:coarse-nonterminals} shows an example of a clustering of constituent symbols in grammars extracted from the English Penn Treebank provided by \citet{Cha06}.
        Creating such a table requires domain-specific knowledge about the corpus and the underlying language.
        \Citet{Doran99} give a coarse tagset used in the english \abrv{xtag} grammar.
        \Citet{SchiTeuSt99} give a standardized set of \abrv{pos} symbols in tandem with a coarse categorization used in German corpora.
        These categories can substitute the \abrv{pos} symbols in the constituent symbols that were constructed during a binarization with a horizontal Markovization window \(h>0\).
    \end{example}


    \begin{table}
        \caption{\label{tab:coarse-nonterminals}
            Clusters of constituent symbols are used in a coarse-to-fine parsing approach \citep{Cha06}.
            The authors extract coarse grammar rules using cluster names instead of constituent symbols as nonterminals.
            These grammar rules are used to find candidate parses, which aid in a parsing process with a finer grammar defined over the original constituent symbols.
        }
        \medskip
        \centering
        \begin{tabular}{ll}
            \toprule
            cluster & constituent and \abrv{pos} symbols \\
            \midrule
            \nt{S} & \cn{s}, \cn{vp}, \cn{ucp}, \cn{sq}, \cn{sbar}, \cn{sbarq}, \cn{sinv} \\
            \nt{N} & \cn{np}, \cn{nac}, \cn{nx}, \cn{lst}, \cn{x}, \cn{frag} \\
            \nt{A} & \cn{adjp}, \cn{qp}, \cn{conjp}, \cn{advp}, \cn{intj}, \cn{prn}, \cn{prt} \\
            \nt{P} & \cn{pp}, \cn{prt}, \cn{rrv}, \cn{whadjp}, \cn{whadvp}, \cn{whnp}, \cn{whpp} \\
            \bottomrule
        \end{tabular}
    \end{table}

    \paragraph{Nonterminal Constructors for \abrv{Dcp} Supertags}
    Since \abrv{dcp} supertags do not contain \abrv{lcfrs} compositions, the nonterminals occurring in them do not need to be consistent with any fanout.
    We use two additional \emph{extensions} for the classic and coarse nonterminal constructor in the case of dcp supertags:
    \begin{itemize}
        \item The \deflab{nof extension} completely removes the fanout subscripts in all constructed nonterminal symbols.
        \item The \deflab{disc extension} removes the fanout subscript if it is 1 and replaces it by the marker ``$_{\text{disc}}$'' if it is greater than 1; i.e.\@ it distinguishes nonterminals for continuous and discontinuous derivations.
    \end{itemize}
    In \cref{sec:experiments}, we refer to the nonterminal constructors extended by adding the name as a suffix, for instance, \emph{coarse-disc} for the coarse nonterminal constructor with the disc extension.

    \subsection{Lexical Derivation Extraction}\label{sec:extractionalg}
    This small subsection describes how we define a derivation of lexical \abrv{hg} rules using the discussed prerequisites.
    Let's assume we have some constituent structure \(\xi\), an admissible guide \(\varphi\) for \(\xi\) and a nonterminal constructor \(\psi\).
    Let us define two extensions for the guide \(\varphi\):
    \begin{compactitem}
        \item
            \(\varphi^{\text{top}}\) is a partial function that restricts the assignments to the topmost positions:
            For each \(\rho \in \pos(\xi)\), \(\varphi^{\text{top}}(\rho) = \varphi(\rho)\) if there is no \(\rho' \in \ancestors(\rho)\) with \(\varphi(\rho') = \varphi(\rho)\) and otherwise it is undefined.
        \item
            The function \(L\) maps each position \(\rho\) to the set of leaves that \(\varphi^{\text{top}}\) assigns to positions at or below \(\rho\):
                \vspace{-\baselineskip}
                \begin{align*}
                    L(\rho) &= \{ i \in \yield(\xi) \mid \exists \rho' \in \descendants_\xi(\rho)\colon \varphi^{\text{top}}(\rho') = i \} \\
                            &= \yield(\xi|_\rho) \setminus \{ \varphi(\rho') \mid \rho' \in \ancestors(\rho) \}
                \end{align*}
%        \item \(\varphi^{\text{top}}(\rho) = \{\varphi(\rho)\} \setminus \{\varphi(\rho') \mid \rho' \in \ancestors(\rho)\}\) assigns each position \(\rho \in \pos(\xi)\) to a unary set
    \end{compactitem}
    The derivation for \(\xi\), \(\varphi\) and \(\psi\) is defined from top to bottom as follows:
    \begin{itemize}
        \item We start with the root position \(\rho_0 = \varepsilon\).
        \item For the position \(\rho_0\), let \(\rho_1, \ldots, \rho_s\) be the sequence of topmost parallel positions that are descendants of \(\rho_0\) and assigned to another leaf than \(\varphi(\rho_0)\) and ordered concerning the least leaf assigned to the nodes in the subtree:
            \begin{compactitem}
                \item For each \(j \in [s]\), \(\varphi(\parent(\rho_j)) = \varphi(\rho_0) \neq \varphi^{\text{top}}(\rho_j)\), and there is no other \(\rho_{s+1}\) which fulfills this property.
                \item For each \(j,k \in [s]\) with \(j<k\) holds \(\min L(\rho_j) < \min L(\rho_k)\).
            \end{compactitem}
        \item The rule for \(\rho_0\) is of the form \(A_0 \to c_1 \, c_2\; (A_1, \ldots, A_s)\) with
        \begin{compactitem}
            \item \(A_i = \psi(\xi, \rho_i, L(\rho_i))\) for each \(i \in [0,s]\),
            \item \(c_1 = \mathrm{comp}(L(\rho_0), L(\rho_1), \ldots, L(\rho_s))\), and
            \item \(c_2 = \mathrm{scomp}(\xi, (\rho_0, L(\rho_0)), (\rho_1, L(\rho_1)), \ldots, (\rho_s, L(\rho_s)))\).
        \end{compactitem}
        \item The derivation for \(\rho\) is \(d_{\rho_0} = r_{\rho_0}\,(d_{\rho_1}, \ldots, d_{\rho_s})\) where \(r_{\rho_0}\) is the just constructed rule and the other \(d_{\rho_i}\) are the (recursively constructed) derivations for \(\rho_i\).
    \end{itemize}

    The derivation, as described above, constructs exactly one rule per leaf \(i\) in \(\xi\) by identifying the topmost position that \(\varphi\) assigns to \(i\).
    All consecutive nodes assigned to \(i\) as well are condensed into the same rule.
    Each subtree in the derivation \(d\) that was extracted starting at the top node \(\rho\), contains one rule for each leaf in \(L(\rho)\) such that
    \begin{itemize}
        \item the \abrv{lcfrs} projection \(\pi_{\abrv{lcfrs}}(d)\) is a derivation for the linearization of \(L(\rho)\), and
        \item the \abrv{dcp} projection \(\pi_{\abrv{dcp}}(d)\) is a derivation for the tree \(\xi|_\rho\) (except if there is a leaf in \(\yield(\xi|_\rho) \setminus L(\rho)\), then it is replaced by \(\y\)).
    \end{itemize}


    \begin{wrapfigure}[8]{r}{0pt}
        \subfile{figures/guides/example-guide-head.tex}
    \end{wrapfigure}
    \parexample\label{ex:extraction:head}
    The tree to the right shows a running example with the usual illustration of values assigned by a guide next to each inner node.
    The partial function \(\varphi^{\text{top}}\) only assigns the topmost node to each leaf; the assigned values are illustrated in circles if the position is in the preimage of the function.
    Instead of the top three nodes, only the \nt{sbar} node at position \(\varepsilon\) is mapped to \(4\) in the example; the two following nodes (with symbols \nt{s} and \nt{vp}) are not defined in \(\varphi^{\text{top}}\).
    \(L\) maps each position to the encircled values illustrated at or next to descendant positions.
    E.g., the root position is mapped to the set of all leaves;
      the set for position \(1\) does not contain the leaf $4$;
      the set of the lower \nt{vp} node at position \(1\,1\,1\) is \(\{1,5,6\}\).
    Using these two sets, we can construct the derivation for the constituent structure with its guide and, e.g., classic nonterminals.
    For the root position (\(\rho_0 = \varepsilon\)), the sequence of descendant positions assigned to other leaves is \(\rho_1 = 1\,1\,1\) (the bottom \nt{vp} node, which is assigned to 5) and \(\rho_2 = 1\,2\) (the \nt{np} node, which is assigned to 3).
    The \abrv{lhs} and \abrv{rhs} nonterminals are determined from these three positions in the tree and the sets assigned to these positions by \(L\).
    The \abrv{lcfrs} composition is determined from the linearizations of the sets of leaves that \(L\) assigns to the positions: \((\x_1^1\x_2^1\,4\,\x_1^2)\); and the \abrv{dcp} composition from the nodes between \(\rho_0\) and \(\rho_1\) and \(\rho_2\): \(\cn{sbar}(\cn{s}(\cn{vp}(\x_1, 4), \x_2))\).
    The two successors in the derivation are determined in the same fashion starting with \(\rho_1\) and \(\rho_2\); finally, we obtain the following derivation for the whole tree.
    \begin{center}
        \subfile{figures/hybrid/headed.tex}
    \end{center}
    \exampleqed

    % \begin{wrapfigure}[6]{r}{0pt}
    %     \subfile{figures/hybrid/ho-head.tex}
    % \end{wrapfigure}
    % \parexample
    % The example to the right shows a head-outward binarized constituent structure with values assigned by a head guide.
    % The position for the node that was introduced during the binarization procedure (with symbol \(\cn{vp\,\binsym{}}\)) is mapped to the head of the original node, which must also be a descendant with the head-outward strategy.
    % This example shows how the extraction procedure does not preserve the structure from the binarization in the case of the head guide.
    % When all nodes formed during binarization are assigned to the same leaf, they are part of the same rule.
    % The resulting derivation is equivalent to extracting the plain (unbinarized) constituent structure, as shown in the previous example.
    % \begin{center}
    %     \subfile{figures/hybrid/ho-headed-deriv.tex}
    % \end{center}

    \subsection{Viable Combinations of Extraction Parameters}\label{sec:viable-paramters}
    \Cref{sec:binarization,sec:ntconstructors,sec:guides} introduced parameters for the extraction procedure.
    As we have seen in \cref{sec:guides}, the guide constructors expect different prerequisites such that not all combinations of parameter values are compatible.
    The vanilla, strict, least, and near guide constructors make no assumptions regarding the binarization strategy and can be freely combined.
    However, we suspect the vanilla and strict guide constructors are best combined with right-branching binarization because these guides are defined via the right successor of each node.

    The dependent guide constructor expects a binary constituent structure complemented by a head assignment; thus, it can only be coupled with the head-outward binarization strategy.
    Similarly, the head guide constructor expects a head assignment and cannot be coupled with the left- or right-branching binarization strategy.
    Formally, the head-outward binarization strategy produces viable inputs for the head guide constructor, but the canonical head assignments are not helpful when it comes to the extraction:
        A head guide combines all artificial nodes introduced during the binarization and assigns them the same lexical head; hence, the effects of the rank transformation are void.
    The following example illustrates this setting; it produces a rule of rank four that combines all nodes introduced during the head-outward binarization of the former root labeled \cn{s}.
    In our experiments, we use the head guide constructor exclusively in case of no applied rank transformations or case of the head-inward transformation.

    \begin{wrapfigure}[7]{r}{0pt}
        \subfile{figures/hybrid/pilot-ho-head.tex}
    \end{wrapfigure}
    \parexample[Continues \cref{fig:ex:markovization}]
    Consider the constituent structure after applying the head-outward binarization strategy from the previous example and the values assigned by its head guide.
    All nodes constructed from the \cn{s} constituent are assigned to the lexical head \(3\).
    For the root position $\rho_0 = \varepsilon$, four descendant positions are assigned to different lexical heads: $\rho_1 = 1\,1\,1$, $\rho_2=1\,1\,2$, $\rho_3 =1\,2$ and $\rho_4=2$.
    Three of them, namely $\rho_1$, $\rho_2$ and $\rho_4$, are positions of the leaves 1, 2, and 6, respectively; the position \(\rho_3\) points to the subtree with the $\cn{np}$ node.
    The compositions constructed for the root position assume four arguments; the \abrv{dcp} composition contains all the artificial nodes introduced during the binarization.
    The following illustration shows the resulting derivation.
    \begin{center}
        \subfile{figures/hybrid/pilot-ho-head-deriv.tex}
    \end{center}
    \exampleqed

    Aside from these restrictions of compatible binarization strategies and guide constructors, the nonterminal constructors and Markovization parameters can be chosen freely.
    They determine the structure and number of the extracted supertag blueprints.
    \Cref{sec:gridsearch,sec:gridsearch:other} show a vast series of experiments that extract supertag blueprints using many different combinations of extraction parameters.

    \ifSubfilesClassLoaded{%
        \printindex
        \bibliography{../references}%
    }{}
\end{document}