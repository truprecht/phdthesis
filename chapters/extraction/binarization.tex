\documentclass[../../document.tex]{subfiles}

\begin{document}
    \section{Rank Transformations}\label{sec:ranktransformations}
    This section focuses on transformations for constituent trees to restrict occurring node ranks.
    For instance, \emph{binarization} is a standard preprocessing step in constituent parsing that produces trees exclusively equipped with binary nodes.
    In the literature, it is dominantly considered a step transforming a grammar instance \citep[e.g.\@]{KleMan03,Son08,Kal10}, we follow \citet{CraSchBod16} and regard rank transformations for constituent trees.
    As usual, all referenced or described transformations are reversible.

    Binarization is a usual tool to produce grammar instances in normal forms, e.g., the Chomsky normal form for parsing with context-free grammar instances.
    The process was generalized to other grammar formalisms such as \abrv{lcfrs}. \citep{Kal10, Cra12}
    During the process, constituent tree nodes with a rank greater than two are broken down by introducing binary \emph{artificial nodes}.
    These artificial nodes have annotations that clearly distinguish them from the original nodes.
    There are several approaches to constructing the artificial nodes, i.e., the direction in which the nodes are split.
    \Citet{Son08} investigated their influence on parsing with binary context-free grammars obtained using various such approaches.
    \Citet{KleMan03} extend binarization by \emph{Markovization} for the artificial node symbols.
    They show that the extension can produce more compact grammar instances or increase their parsing accuracy.

    In this section, we will first briefly bring up and compare well-established approaches to binarize constituent structures in \cref{sec:binarization}.
    We coarsely follow \citet{Cra12} and characterize the approaches in terms of a \emph{transformation strategy} that defines the structural transformation and extensions (\emph{Markovization, directive indicators, trailing nodes}) that alter the artificial constituent symbols introduced during this step.
    Lastly, we introduce a new strategy to construct trees with at most three successors per node, called \deflab<binarization>[bin:ter]{head-inward transformation}.

    \subsection{Binarization}\label{sec:binarization}
    The \deflab{binarization} of constituent structures removes and replaces nodes that have either one or more than two successors.
    These two cases are handled separately.

    All of the binarization strategies described in this section share the approach for dealing with chains of nodes having one successor:
    \begin{inparaenum}
        \item If the successor of the bottom-most node in the chain is an inner node, then they are merged into this successor.
        \item If the successor of the bottom-most node in the chain is a leaf, they are merged with the \abrv{pos} symbol for the leaf.
    \end{inparaenum}
    The merged symbols must not occur in the original alphabets of constituent and \abrv{pos} symbols and must be unique for each sequence of merged constituent/\abrv{pos} symbols.
    Here, the merged nodes are denoted by concatenating the symbols interleaved by \cn{+}.
    E.g.\@ a chain of unary nodes ``\cn{root}'', ``\cn{s}'' that is merged with the \abrv{pos} symbol ``\cn{\$.}'' is the new symbol ``\cn{root+s+\$.}''.
    This approach of handling nodes with one successor is done after dealing with nodes with more than two successors.
    Because this is common among all binarization strategies, we view only the other case as part of the strategies.

    Each node carrying \( n > 2 \) successors is split into \( n-1 \) binary nodes that are connected in some parent-child constellation.
    The topmost of these nodes will carry the label of the original node. Each following is a new symbol (i.e., the symbol must not be a constituent symbol in the original tree) determined by the binarization strategy.
    The strategy also dictates how each node is split and how the new nodes are connected.
    Because all binarization strategies are defined per node, we will formalize each binarization strategy as a function that replaces the root node in a constituent tree (if it has more than two successors) with a collection of binary nodes.
    The function is then called recursively to handle each subtree.

    The reversal of the binarization procedure is independent of the binarization strategy:
    \begin{compactenum}
        \item All binary nodes with symbols introduced by the binarization procedure are removed, and their children are appended to their parents.
        \item Each node originating from a merge of unary nodes is expanded by replacing it with the chain of unary nodes.
        \item Each \abrv{pos} symbol originating from a merge is replaced by the trailing pos symbol, and the sequence of unary nodes is inserted atop the corresponding leaf in the constituent structure.
    \end{compactenum}

    %    \begin{definition}
        %        Let \(\varSigma, \varPi\) and \(\varGamma\) be some alphabets.
        %        A binarization strategy \(b\) for \(\CT_{\varGamma \varPi \varSigma}\) defines
        %        \begin{compactenum}
            %            \item an alphabet of constituent symbols \(b(\varGamma)\),
            %            \item an alphabet of \abrv{pos} symbols \(b(\varPi)\),
            %            \item a function \(f\colon \CT_{\varGamma \varPi \varSigma} \to \CT_{b(\varGamma) b(\varPi) \varSigma}\) that transforms a constituent tree into a constituent tree with a binary root, and
            %            \item a partial function \(f^{-1} \colon \CT_{b(\varGamma) b(\varPi) \varSigma} \parto \CT_{\varGamma \varPi \varSigma}\) that reverses the transformation \(f\).
            %        \end{compactenum}
        %        The binarization operation, denoted just by \(b\), extends the function \(f\) such that \todo{formal definition is complicated, as we deal with constituent trees}
        %    \end{definition}

    \paragraph{Left- or Right-Branching Binarization.}
    These strategies replace each node with \( n>2 \) successors with a series of \( n-1 \) binary nodes.
    The \deflab<binarization!binarization strategies>[binarization:l2r]{right-branching strategy} (short: \abrv{rb}) constructs nodes as follow:
    \begin{itemize}
        \item The first (and topmost) node has the same symbol as the original node.
        \item For each \(2 \leq i \leq n-1\), the \(i\)th node's symbol consists of the original node's symbol and the symbols of its rightmost \(n-i-1\) successors. Those symbols are denoted in the form \(\binnode{A}{B_i,B_{i+1},\ldots,B_n}\) where \(A\) is the root node and \(B_1, \ldots, B_n\) are its children.
        \item For each \(1 \leq i \leq n-2\), the left successor of the \(i\)-th node is the \(i\)-th successor of the original node, and its right successor is the \((i+1)\)-th constructed node.
        \item The successors of the last (bottom-most) node are the two rightmost successors of the original node.
    \end{itemize}
    The \deflab<binarization!binarization strategies>[binarization:r2l]{left-branching strategy} (short: \abrv{lb}) mirrors the right-branching strategy: It constructs a series of binary nodes connected via their left successors in the opposite direction.
    If a binarized constituent tree was complemented by a head assignment, then it is lost after applying the left- or right-branching binarization strategy; there is no reasonable head assignment that can be obtained after such binarization.

    \paragraph{Head-Outward Binarization.}
    The \deflab<binarization!binarization strategies>[binarization:ho]{head-outward strategy} (short: \abrv{ho}) mixes the left- and right-branching strategies at each higher-ranked node depending on the successor that contains its lexical head.
    If the node is of rank \(k\) and its lexical head is at or below its \(n\)-th successor, then
    \begin{enumerate}
        \item the trailing \(k-n\) successors are split according to the left-branching binarization strategy forming \(k-n-1\) artificial nodes, and
        \item the first \(n-1\) successors are split according to the right-branching binarization strategy, forming another \(n-1\) artificial nodes.
    \end{enumerate}
    In the resulting constituent tree, the lexical head is in the yield of the bottom-most constructed node.
    In bottom-up parsing processes, the bottom-most nodes are explored first, and the constituent symbol is determined.
    This binarization strategy can be advantageous in such settings, as the first explored node contains the lexical head.
    We use distinct symbols for the introduced top left-branching nodes and the bottom right-branching nodes to avoid ambiguities during parsing with the extracted grammar instances.
    In these symbols, the left symbol \(\langle\) is doubled in left-branching nodes, and the right symbol \(\rangle\) is doubled in right-branching nodes.
    We call these \emph{directive indicators} for artificial nodes; \cref{fig:ex:markovization} shows an example involving these indicators.
    For each constituent tree that is binarized using the head-outward strategy, there is a canonical head assignment that is obtained by additionally assigning each artificial node to its origin's head; the first and last tree in \cref{fig:ex:binarization:2} illustrate an example.
    The head-outward strategy is the only investigated rank transformation that obtains binary trees complemented with a head assignment.

    \begin{figure}
        \null\hfill
        \subfile{figures/binarization/pilot.tex}
        \hspace{.5cm}
        \begin{minipage}{.4\linewidth}
            \subcaption{Plain constituent tree with illustrated lexical head-assignment}
        \end{minipage}

        \vspace{.5cm}

        \begin{minipage}{.4\linewidth}
            \subcaption{Right-branching binarized constituent tree}
        \end{minipage}
        \hspace{.5cm}
        \subfile{figures/binarization/pilot-binary.tex}
        \hfill\null

        \vspace{.5cm}

        \null\hfill
        \subfile{figures/binarization/pilot-binary-lf.tex}
        \hspace{.5cm}
        \begin{minipage}{.4\linewidth}
            \subcaption{Left-branching binarized constituent tree}
        \end{minipage}

        \vspace{.5cm}

        \begin{minipage}{.4\linewidth}
            \subcaption{Head-outward binarized constituent tree with illustrated lexical head-assignment}
        \end{minipage}
        \hspace{.5cm}
        \subfile{figures/binarization/pilot-binary-ho.tex}
        \hfill\null

        \vspace{.5cm}

        \caption{\label{fig:ex:binarization:2}
            A constituent tree was binarized with left-branching, right-branching, and head-outward binarization strategies.
        }
    \end{figure}

    \paragraph{Minimizing Fanout or Parsing Complexity.}
    Two binarization strategies specifically consider the properties of \abrv{lcfrs} instances extracted from constituent treebanks after binarization.
    \Citet{gomez2009optimal} criticize that the usual strategies can produce constituent nodes with larger fanout than in the original treebank.
    The parsing complexity with \abrv{lcfrs} instances depends on the fanouts, so binarization strategies may influence the parsing effort.
    They propose a binarization strategy that minimizes the fanouts in its results.
    \Citet{Gil10} argue that the parsing complexity not only depends on the single occurring fanouts but on the combination of fanouts in each node and its children.
    They adapt the strategy to minimize the sum of fanouts in such node triplets.
    In contrast to the previous strategies, these two scramble the order of the successors in the constructed subtrees.
    They are rarely considered in parsing, and experiments conducted by \citet{Cra12} show underwhelming results regarding parse time and accuracy.
    We do not investigate these two strategies in our experiments.

    \begin{figure}
        \resizebox{.3\linewidth}{!}{\subfile{figures/binarization/survey.tex}}\hfill
        \resizebox{.3\linewidth}{!}{\subfile{figures/binarization/survey-binary.tex}}\hfill
        \resizebox{.3\linewidth}{!}{\subfile{figures/binarization/survey-binary-lf.tex}}

        \vspace{.5cm}

        \resizebox{.3\linewidth}{!}{\subfile{figures/binarization/hearing.tex}}\hfill
        \resizebox{.3\linewidth}{!}{\subfile{figures/binarization/hearing-binary.tex}}\hfill
        \resizebox{.3\linewidth}{!}{\subfile{figures/binarization/hearing-binary-lf.tex}}

        \caption{\label{fig:ex:binarization}
            Comparing the two left- and right-branching binarization strategies in our two running examples.
            In both cases, head-outward binarization coincides with right-branching binarization.
        }
    \end{figure}


    \subsection{Markovization}
    The symbols introduced by all binarization strategies contain the symbol of the substituted node \(A\) and the symbols in the successors \(B_1, \ldots, B_k\) below these (intermediate) nodes.
    They are chosen to represent an intermediate state in parsing the original non-binary rule.

    Markovization is an extension to the binarization strategies that change the constructed labels such that they contain only the symbols of the last \(h\) successors that were recently processed.
    The value \(h\) is called the \emph{horizontal Markovization window} and is considered a parameter for binarization.
    With large values for \(h\), the symbols are unchanged in the formulation of the binarization strategy.
    If we choose a small value for \(h\), this generalizes the symbols such that they are common in binarized constituent trees where nodes with the same symbol and similar successors are binarized.
    In the edge case of \(h=0\), there is no information about the children, and all symbols constructed during the binarization of a node with the same symbol are the same.

    Additional to the horizontal window \(h\), there is a \emph{vertical context} \(v\) that may add information from the parent symbols for each node in the constituent tree (and not just the nodes introduced during the binarization).
    With values greater than 1, the last \(v-1\) parents are added to each node in the constituent structure.
    A sequence of additional parent symbols is denoted by concatenating them, interleaved by ``$^\wedge$'', as a superscript to the symbol's right.
    \Cref{fig:ex:markovization} shows an example where the node carrying the symbol \cn{np} is extended by its former parent symbol \cn{s}.

    \begin{figure}
        \centering
        \subfile{figures/binarization/pilot-binary-ho-v2-h0.tex}
        \caption{\label{fig:ex:markovization}
            A binary constituent structure was obtained using the head-outward binarization strategy.
            The artificial nodes do not include information about the successor symbols. The horizontal Markovization window is \(h = 0\).
            The node labeled by \label{np} is extended by its parent in the original constituent structure. The vertical Markovization window is \(v = 2\).}
    \end{figure}


    \subsection{Head-Inward Transformation} \label{sec:extraction:bin:hi}
    A later section deals with a grammar extraction strategy borrowed from dependency parsing, cf.\@ \emph{head guides} in \cref{sec:guides}.
    In early experiments, the grammars obtained by this strategy tended to be rather large, and the binarization strategies mentioned above either failed to decrease their size or there was no intuitive strategy to obtain lexical head assignments for the constituent trees after binarization.
    This issue is described in more detail at the end of \cref{sec:viable-paramters}.
    We came up with the following rank transformation and a complementary head assignment for its result that tackles this problem but does not yield binary trees in general.
    It can be seen as the opposite of head-outward binarization because when a node is expanded with artificial children, it does keep the child carrying the head at the topmost position.
    All other children are distributed as or into (artificial) child nodes to the left or right of this head-carrying child.
    The process coincides with the node splitting in right-branching binarization if the head assignment strictly maps each inner node to the leftmost leaf (and vice versa).
    As we omit removing unary nodes in this transformation, the results may appear different even in said cases.

%    This strategy uses the head assignment for each inner node in the constituent tree, much like the head-outward binarization strategy.
    More formally: For each inner node \(\rho\) with \(n > 2\) successors whose head is located in the \(i\)-th child (for \(i \in [n]\)), it introduces artificial binary nodes for the successors \(1, \ldots, i-1\) and \(i+1, \ldots, n\) as usual with the right-branching strategy, respectively.
    These artificial nodes and the \(i\)th child are attached to \(\rho\), composing a node with at most three non-leaf successors.
    For the resulting tree, there is a canonical head assignment that preserves the head for each non-artificial node; each artificial node is assigned to the head of the left successor in case of nodes constructed using the right-branching strategy and vice versa.
    The process is extended with Markovization and directive indicators for the artificial nodes in the same manner as the binarization strategies.
    Moreover, we add an artificial (unary) node concluding each sequence of right-branching artificial nodes as a parent of the \(i-1\)th and \(n\)-th successor.
    \Cref{fig:ex:head-inward} shows an example of a constituent structure obtained by this rank transformation.
%    \begin{itemize}
%        \item with Markovization annotations at each node,
%        \item with indicators for the direction that was used to introduce artificial binary nodes,
%        \item with trailing artificial unary nodes concluding each sequence of artificial binary nodes.
%    \end{itemize}

    \begin{figure}
        \centering
        \subfile{figures/binarization/pilot-head-inward.tex}
        \caption{\label{fig:ex:head-inward}
            A constituent tree was obtained using the head-inward rank transformation.
        }
    \end{figure}
\end{document}