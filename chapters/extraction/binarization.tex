\documentclass[../../document.tex]{subfiles}

\begin{document}
    \section{Binarization} \todo{clearify the term binarization: construct constituent tree where each node has exactly 0 or 2 successors}
    In a treebank, we may encounter nodes in constituent trees with arbitrary amounts of successors.
    \todo{add an example of successor distributions in a treebank}
    Most grammar extraction procedures share the common property that they construct a rule for each inner node (or a set of inner nodes) in a constituent tree with the rank matching the number of successors of the node (or the sum of successor in the set of nodes).
    Usually it is desirable to obtain binary grammars, because the design of efficient parsing algorithms is more straightforward.
    And more importantly, these binary grammars can be constructed in such a way that rules contained in similar derivations are shared and allow more general derivations.
    This can be achieved by \deflab<binarization>[bin:markov]{markovization} and choosing appropriate \deflab<binarization>[bin:strat]{binarization strategies}, which has shown to improve the parsing quality and time. \citep{Son08,Cra12}
    There are also specific binarization strategies for \abrv{lcfrs} capable of minimizing the parsing complexity of the resulting grammar. \citep{Gil10}

    In the scope of this thesis, we view binarization as a preprocessing step for constituent trees rather than grammars.
    I.e.\@ it is an operation that transforms a given constituent tree into a \hyperlink{binctree}{binary} constituent tree such that it can be transformed back into the original constituent tree.
    The binarization process affords new constituent symbols that will appear in the place of nodes with one or more than two successors.
    The form of these additional symbols is determined by the chosen binarization strategy and markovization parameters.

    \subsection{Binarization Strategies}\todo{what exactly is a binarization strategy}
    The \deflab{binarization} of constituent structures removes and replaces nodes that have either one or more than two successors.
    These two cases are handled separately.

    All of the binarization strategies described in this section share the approach for dealing with chains of nodes having one successor:
    \begin{inparaenum}
        \item if the successor of the bottom-most node in the chain is an inner node, they are merged into this successor, or
        \item if the successor of the bottom-most node in the chain is a leaf, they are merged with the \abrv{pos} symbol for the leaf.
    \end{inparaenum}
    The merged symbols must not occur in the original alphabets of constituent and \abrv{pos} symbols, and must be unique for each sequence of merged constituent/\abrv{pos} symbols.
    Here, the merged nodes are denoted by concatenating the symbols interleaved by \cn{+}.
    E.g.\@ a chain of unary nodes ``\cn{root}'', ``\cn{s}'' that is merged with the \abrv{pos} symbol ``\cn{\$.}'' is the new symbol ``\cn{root+s+\$.}''.
    This approach of handling nodes with one successor is done after dealing with nodes with more than two successors.
    Because this is common among all binarization strategies, we view only the other case as an actual part of the strategies.

    Each node carrying \( n > 2 \) successors is split into \( n-1 \) binary nodes that are connected in some parent-child constellation.
    The topmost of these nodes will carry the label of the original node, each following is a new symbol (i.e.\@ the symbol must not be a constituent symbol in the original tree) determined by the binarization strategy.
    The strategy also dictates how each node is split and how the new nodes are connected.
    Because all binarization strategies are defined per-node, we will formalize each binarization strategy as a function that replaces the root node in a constituent tree (if has more than 2 successors) with a collection of binary nodes.
    The function is then called recursively to handle each subtree.

    The reversal of the binarization procedure is also independent of the strategy:
    \begin{compactenum}
        \item all binary nodes with symbols that were introduced by the binarization procedure are removed and their children are appended to their parent, and
        \item each node originating from a merge of unary nodes is expanded by replacing it with the chain of unary nodes, and
        \item each \abrv{pos} symbol originating from a merge is replaced by the trailing pos symbol and the sequence of unary nodes is inserted atop of the corresponding leaf in the constituent structure.
    \end{compactenum}

    %    \begin{definition}
        %        Let \(\varSigma, \varPi\) and \(\varGamma\) be some alphabets.
        %        A binarization strategy \(b\) for \(\CT_{\varGamma \varPi \varSigma}\) defines
        %        \begin{compactenum}
            %            \item an alphabet of constituent symbols \(b(\varGamma)\),
            %            \item an alphabet of \abrv{pos} symbols \(b(\varPi)\),
            %            \item a function \(f\colon \CT_{\varGamma \varPi \varSigma} \to \CT_{b(\varGamma) b(\varPi) \varSigma}\) that transforms a constituent tree into a constituent tree with binary root, and
            %            \item a partial function \(f^{-1} \colon \CT_{b(\varGamma) b(\varPi) \varSigma} \parto \CT_{\varGamma \varPi \varSigma}\) that reverses the transformation \(f\).
            %        \end{compactenum}
        %        The binarization operation, denoted just by \(b\), extends the function \(f\) such that \todo{formal definition is complicated, as we deal with constituent trees}
        %    \end{definition}

    \paragraph{Left- or Right-Branching Factorization}
    These strategies replace each node with \( n>2 \) successors with a series of \( n-1 \) binary nodes.
    The \deflab<binarization!binarization strategies>[binarization:l2r]{right-branching factorization} constructs nodes such that
    \begin{itemize}
        \item the first (and top-most) node has the same symbol as the original node,
        \item for each \(2 \leq i \leq n-1\), the \(i\)-th node's symbol consists of the original node's symbol and the symbols of its rightmost \(n-i-1\) successors. Those symbols are denoted in the form \(\binnode{A}{B_i,B_{i+1},\ldots,B_n}\) where \(A\) is the root node and \(B_1, \ldots, B_n\) are its
        \item for each \(1 \leq i \leq n-2\), the left successor of the \(i\)-th node is the \(i\)-th successor of the original node, and its right successor is the \((i+1)\)-th constructed node, and
        \item the successors of the last (an bottom-most) node are the two rightmost successors of the original node.
    \end{itemize}
    The \deflab<binarization!binarization strategies>[binarization:r2l]{left-branching factorization} mirrors the right-branching strategy: It constructs a series of binary nodes connected via their left successors in the opposite direction.

    \paragraph{Head-Outward Binarization.}
    This \deflab<binarization!binarization strategies>[binarization:r2l]{head-outward binarization}[strategy] mixes left- and right-branching factorization depending on the successor that contains the head symbol of the node.
    If the node's head symbol is contained in its \(n\)-th successor, then
    \begin{enumerate}
        \item the first \(k-n\) (top-most) binary nodes are constructed according to the left-branching binarization strategy for the trailing \(k-n\) successors, and
        \item the remaining \(n-1\) binary nodes are constructed according to the right-branching strategy for the first \(n\) successors.
    \end{enumerate}
    In the resulting constituent tree, the head symbol is in the yield of the bottom-most constructed node.
    The motivation for choosing this strategy is that in bottom-up parsers the head symbol is processed first and determines the constituent symbol.
    There are distinct notations for the introduced top left-branching nodes and the bottom right-branching nodes to avoid ambiguities during parsing with the extracted grammars (which is pretty common in combination with markovization).
    In these notations, the left symbol \(\langle\) is doubled in left-branching nodes, and the right symbol \(\rangle\) is doubled in right-branching nodes.

    \paragraph{Minimizing Fanout or Parsing Complexity.}
    These two strategies replace non-binary nodes with a combination of new binary nodes such that an assessment function for the resulting tree is minimized.
    In the \deflab<binarization!binarization strategies>[bin:minfo]{minimal fanout binarization}[first case], this function coincides with the occurring fanouts.
    In the \deflab<binarization!binarization strategies>[bin:minpc]{minimal parsing complexity binarization}[latter case], it is a combination of the the parsing complexity and fanout.
    In contrast to the previous binarization strategies, these two may not only scramble the order of the successors in the constructed subtrees, but also construct branches of intermediate nodes in both directions.
    As the two previous strategies, the symbols at the constructed nodes contain the parent constituent symbol and the constituent symbol of the processed successors.

    \begin{figure}
        \todo[inline]{beispiel für binarisierung einfügen}
        \caption{\label{fig:ex:binarization}
            Comparing different binarization strategies, in order from left to right: right-branching, left-branching factorization, head-outward binarization, minimal fanout and minimal parsing complexity binarization.}
    \end{figure}

    \subsection{Head-Inward Ternarization: Not Quite Binarization} \label{sec:extraction:bin:hi}
    %    The strategy to binarize constituent trees head-outward takes account of the head assignment for each inner node of the constituent structure.
    %    For each node of rank \(\ge 2\), it produces a series of nodes such that the child containing the head is attached to the bottom-most node.
    \todo[inline]{ist das nötig? die Struktur der Ableitung sollte ausschließlich vom Guide abhängen.}


    \subsection{Markovization}
    The symbols introduced by all binarization strategies contain the symbol of the substituted node \(A\) and the symbols in the successors \(B_1, \ldots, B_k\) below these (intermediate) nodes.
    They are chosen such that there are represent an intermediate state in parsing the original non-binary rule.

    Markovization is an extension to the binarization strategies that changes the constructed labels such that they contain only the symbols of the last \(h\) successors that were recently processed.
    The value \(h\) is called the \emph{horizontal markovization window} and is considered a parameter for the binarization.
    With very large values for \(h\), the symbols are unchanged to the formulation in the binarization strategy.
    If the value for \(h\) is chosen small, this generalizes the symbols such that they are common in binarized constituent trees where nodes with the same symbol and similar successors were binarized.
    In the edge case of \(h=0\), there is no information about the children and all symbols constructed during the binarization of node with the same symbol are the same.

    Additional to the horizontal window \(h\), there is a \emph{vertical context} \(v\) that may add information from the parent symbols for each node in the constituent tree (and not just the nodes introduced during the binarization).
    With values greater than 1, the last \(v-1\) parents are added to each node in the constituent structure.
    The additions are denoted without ambiguity, such that they can be easily removed and the original constituent tree is obtained.
    Here, a sequence of additional parent symbols are denoted by concatenating them, interleaved by ``\cn{$\wedge$}'', to the right of the symbol.

    \begin{figure}
        \todo[inline]{beispiel oben im vgl. mit Markovisierung einfügen}
        \caption{\label{fig:ex:markovization}
            Comparing two constituent trees and their binarized forms with markovization parameters \(v=2\) and \(h=0\).}
    \end{figure}
\end{document}